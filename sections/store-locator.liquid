{{ 'leaflet.css' | asset_url | stylesheet_tag }}
<script src="{{ 'leaflet.min.js' | asset_url }}" defer></script>

<style>
  #map {
    height: 700px;
    filter: grayscale(100%);
  }
  .store-locator__container {
    display: flex;
    gap: 20px;
  }
  .store-locator__map {
    flex: 1;
  }
  .store-locator__sidebar {
    width: 400px;
    overflow-y: auto;
    max-height: 700px;
  }
  .location-item {
    padding: var(--space-m);
    border-bottom: 1px solid var(--neutral-200);
  }
  .location-item__header {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    margin-bottom: var(--space-s);
  }
  .location-item__status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--green-400);
    flex-shrink: 0;
  }
  .location-item__status-dot--closed {
    background-color: #ff0000;
  }
  .location-item__title {
    margin: 0;
  }
  .location-item__address {
    margin-bottom: var(--space-xs);
  }
  .location-item__contact {
    margin-bottom: var(--space-xs);
  }
  .location-item__hours {
    margin: 0;
  }
  .location-item a {
    color: var(--neutral-950);
  }
</style>

<div class="store-locator" x-data="storeLocator()">
  <h2>Store Locations</h2>

  <div class="store-locator__filters">
    <input
      type="text"
      x-model="searchTerm"
      @input="filterLocations"
      class="store-locator__search"
      placeholder="Search by name, address or state"
    >
    <select x-model="selectedState" @change="filterLocations" class="store-locator__state-select">
      <option value="WA">WA</option>
      <option value="NT">NT</option>
      <option value="SA">SA</option>
      <option value="QLD">QLD</option>
      <option value="NSW">NSW</option>
      <option value="VIC" selected>VIC</option>
      <option value="ACT">ACT</option>
      <option value="TAS">TAS</option>
    </select>
  </div>

  <div class="store-locator__container">
    <div class="store-locator__map">
      <div id="map"></div>
    </div>

    <div class="store-locator__sidebar">
      {% for location in metaobjects.locations.values %}
        <div
          class="location-item"
          x-show="isLocationVisible('{{ location.location_name.value }}', '{{ location.address.value | default: '' }}', '{{ location.location_state.value | default: '' }}')"
          data-lat="{{ location.latitude.value }}"
          data-lng="{{ location.longitude.value }}"
          data-state="{{ location.location_state.value }}"
          data-hours="{{ location.opening_hours.value }}"
        >
          <div class="location-item__header">
            <div
              class="location-item__status-dot"
              data-location-status="{{ location.location_name.value | handleize }}"
            ></div>
            <h3 class="location-item__title heading--xl">{{ location.location_name.value }}</h3>
          </div>

          <div class="location-item__address body">
            <a href="{{ location.google_maps_link.value }}">{{ location.street_address.value }}</a>
          </div>

          <div class="location-item__contact body">
            <a href="mailto:{{ location.email_address.value }}">{{ location.email_address.value }}</a> |
            <a href="tel:{{ location.phone_number.value }}">{{ location.phone_number.value }}</a>
          </div>

          <div class="location-item__hours body">
            <strong>Open Today:</strong>
            <span data-today-hours="{{ location.location_name.value | handleize }}">
              {{- location.opening_hours.value -}}
            </span>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
</div>

<script>
// Alpine.js component
function storeLocator() {
  return {
    searchTerm: '',
    selectedState: 'VIC',
    markers: [],
    map: null,
    timezoneHandler: null,
    
    init() {
      // Get search term from URL
      const urlParams = new URLSearchParams(window.location.search);
      const querySearch = urlParams.get('search');
      if (querySearch) {
        this.searchTerm = querySearch;
      }
      
      // Initialize timezone handler
      this.timezoneHandler = new ShopifyTimezoneHandler();
      
      // Initialize map after Alpine is ready
      this.$nextTick(() => {
        this.initMap();
        this.filterLocations();
        this.updateAllLocationTimes();
        // Update times every minute
        setInterval(() => this.updateAllLocationTimes(), 60000);
      });
    },
    
    initMap() {
      // Initialize map centered on Australia
      this.map = L.map('map').setView([-25.2744, 133.7751], 5);

      // Add black and white tile layer
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap contributors',
        maxZoom: 18
      }).addTo(this.map);

      // Create custom icon
      var storeIcon = L.icon({
        iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
        shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

      // Add markers for each location
      {% for location in metaobjects.locations.values %}
        {% if location.latitude.value and location.longitude.value %}
          var marker = L.marker([{{ location.latitude.value }}, {{ location.longitude.value }}], {icon: storeIcon})
            .bindPopup(`
              <div class="location-item__header">
                <h3 class="location-item__title heading--xl">{{ location.location_name.value }}</h3>
              </div>
              <div class="location-item__address body">
                <a href="{{ location.google_maps_link.value }}">{{ location.street_address.value }}</a>
              </div>
              <div class="location-item__contact body">
                <a href="mailto:{{ location.email_address.value }}">{{ location.email_address.value }}</a><br>
                <a href="tel:{{ location.phone_number.value }}">{{ location.phone_number.value }}</a>
              </div>
              <div class="location-item__hours body">
                <a href="{{ location.location_page_url.value }}">View Location Details</a>
              </div>
            `);
          marker.locationData = {
            name: '{{ location.location_name.value }}',
            address: '{{ location.address.value | default: '' }}',
            state: '{{ location.location_state.value | default: '' }}'
          };
          this.markers.push(marker);
          marker.addTo(this.map);
        {% endif %}
      {% endfor %}
    },
    
    isLocationVisible(name, address, state) {
      const searchLower = this.searchTerm.toLowerCase();
      const matchesSearch = !this.searchTerm || 
        name.toLowerCase().includes(searchLower) ||
        address.toLowerCase().includes(searchLower) ||
        state.toLowerCase().includes(searchLower);
      
      const matchesState = !this.selectedState || state === this.selectedState;
      
      return matchesSearch && matchesState;
    },
    
    filterLocations() {
      // Filter markers on map
      this.markers.forEach(marker => {
        const data = marker.locationData;
        if (this.isLocationVisible(data.name, data.address, data.state)) {
          marker.addTo(this.map);
        } else {
          marker.remove();
        }
      });
    },
    
    updateAllLocationTimes() {
      const locationItems = document.querySelectorAll('.location-item');
      locationItems.forEach(item => {
        const state = item.getAttribute('data-state');
        const hours = item.getAttribute('data-hours');
        const locationId = item.querySelector('[data-location-status]').getAttribute('data-location-status');
        
        if (state && hours) {
          const timeData = this.timezoneHandler.getStateTime(state);
          const openingStatus = this.timezoneHandler.checkOpeningStatus(timeData, hours);
          
          // Update status dot
          const statusDot = item.querySelector('[data-location-status]');
          if (statusDot && openingStatus) {
            if (openingStatus.isOpen) {
              statusDot.classList.remove('location-item__status-dot--closed');
            } else {
              statusDot.classList.add('location-item__status-dot--closed');
            }
          }
          
          // Update today's hours display
          const todayHoursElement = item.querySelector('[data-today-hours]');
          if (todayHoursElement && openingStatus) {
            todayHoursElement.textContent = openingStatus.hours || 'Hours not available';
          }
        }
      });
    }
  }
}

// Timezone Handler Class (copied exactly from location-hero.liquid)
class ShopifyTimezoneHandler {
  constructor() {
    this.timezones = {
      NSW: 'Australia/Sydney',
      VIC: 'Australia/Melbourne',
      QLD: 'Australia/Brisbane',
      SA: 'Australia/Adelaide',
      WA: 'Australia/Perth',
      TAS: 'Australia/Hobart',
      NT: 'Australia/Darwin',
      ACT: 'Australia/Sydney',
    };
    this.dstStates = ['NSW', 'VIC', 'SA', 'TAS', 'ACT'];
  }

  getStateTime(state) {
    if (!this.timezones[state]) {
      console.error(`Unknown state: ${state}`);
      return null;
    }

    const timezone = this.timezones[state];
    const now = new Date();

    const formatter = new Intl.DateTimeFormat('en-AU', {
      timeZone: timezone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false,
      weekday: 'long',
    });

    const parts = formatter.formatToParts(now);
    const timeData = {};
    parts.forEach((part) => (timeData[part.type] = part.value));

    const offsetFormatter = new Intl.DateTimeFormat('en', {
      timeZone: timezone,
      timeZoneName: 'longOffset',
    });
    const currentOffset = offsetFormatter.formatToParts(now).find((part) => part.type === 'timeZoneName').value;

    const isDSTActive = this.isDSTActive(timezone, now);

    return {
      state: state,
      time: `${timeData.hour}:${timeData.minute}`,
      day: timeData.weekday,
      date: `${timeData.day}/${timeData.month}/${timeData.year}`,
      offset: currentOffset,
      isDST: isDSTActive,
      observesDST: this.dstStates.includes(state),
    };
  }

  isDSTActive(timezone, date = new Date()) {
    const january = new Date(date.getFullYear(), 0, 15);
    const july = new Date(date.getFullYear(), 6, 15);

    const janOffset = this.getOffset(timezone, january);
    const julOffset = this.getOffset(timezone, july);
    const currentOffset = this.getOffset(timezone, date);

    return janOffset !== julOffset && currentOffset === janOffset;
  }

  getOffset(timezone, date) {
    return new Intl.DateTimeFormat('en', {
      timeZone: timezone,
      timeZoneName: 'longOffset',
    })
      .formatToParts(date)
      .find((part) => part.type === 'timeZoneName').value;
  }

  checkOpeningStatus(timeData, openingHours) {
    if (!timeData || !openingHours) return null;

    const hoursLines = openingHours.split('\n');
    const currentDay = timeData.day;
    const currentTime = timeData.time;

    for (let line of hoursLines) {
      if (line.includes(currentDay)) {
        const parts = line.split(': ');
        if (parts.length < 2) continue;

        const todayHours = parts[1].trim();

        if (todayHours === 'Closed') {
          return {
            isOpen: false,
            status: 'Closed today',
            hours: todayHours,
          };
        }

        const timeRange = todayHours.split(' - ');
        if (timeRange.length !== 2) continue;

        const [openTime, closeTime] = timeRange;

        const currentMinutes = this.timeToMinutes(currentTime);
        const openMinutes = this.timeToMinutes(openTime);
        const closeMinutes = this.timeToMinutes(closeTime);

        const isOpen = currentMinutes >= openMinutes && currentMinutes <= closeMinutes;

        return {
          isOpen: isOpen,
          status: isOpen ? `Open until ${closeTime}` : `Closed (opens at ${openTime})`,
          hours: todayHours,
          openTime: openTime,
          closeTime: closeTime,
        };
      }
    }

    return {
      isOpen: false,
      status: 'Hours not available',
      hours: 'Unknown',
    };
  }

  timeToMinutes(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
  }
}
</script>

{% schema %}
{
  "name": "Store Locator",
  "tag": "section",
  "class": "section",
  "settings": [],
  "presets": [
    {
      "name": "Store Locator"
    }
  ]
}
{% endschema %}
