<div
  id="site-header"
  class="header container"
  onclick="window.closeMenu(); window.closeFilter && window.closeFilter();"
>
  <button
    type="button"
    class="hamburger-menu"
    onclick="event.stopPropagation(); window.toggleNav();"
    aria-expanded="false"
    aria-controls="site-navigation"
    aria-label="Toggle menu"
  >
    <div class="hamburger-icon">
      {% render 'icon-hamburger-menu', accessible_name: 'Menu' %}
    </div>
  </button>
  <div class="header__logo">
    <a href="/" aria-label="Peter Jackson - Home">
      {% render 'icon-peter-jackson', accessible_name: 'Peter Jackson', role: 'img' %}
    </a>
  </div>
  <ul class="header__icons">
    <li class="header__search-desktop">
      <button
        type="button"
        onclick="window.toggleSearch();"
        aria-label="Search"
        style="background: none; border: none; padding: 0; cursor: pointer; display: flex; align-items: center; justify-content: center;"
      >
        {% render 'icon-site-search', accessible_name: 'Search', role: 'img' %}
      </button>
    </li>
    <li>
      <a href="{{ routes.account_url }}" aria-label="Account">
        {% render 'icon-account', accessible_name: 'Account', role: 'img' %}
      </a>
    </li>
    <li>
      <button
        type="button"
        aria-label="Cart{% if cart.item_count > 0 %} with items{% endif %}"
        style="background: none; border: none; padding: 0; cursor: pointer; text-decoration: none; position: relative;"
        class="js-cart-icon"
      >
        {%- render 'icon-cart', accessible_name: 'Shopping Cart', role: 'img' %}
        <span class="cart-indicator {% if cart.item_count == 0 %}hide{% endif %}" aria-hidden="true"></span>
      </button>
    </li>
  </ul>
</div>

{% render 'menu', id: 'site-navigation' %}

<script>
  document.addEventListener('alpine:init', () => {
    Alpine.data('scrollManager', () => ({
      // Current scroll position
      scrollY: 0,

      // Whether header should be sticky based on scroll position
      isSticky: false,

      // Whether any drawer is currently open
      isDrawerOpen: false,

      // Stored scroll position when drawer opens
      storedScrollPosition: 0,

      // Header height for calculations
      headerHeight: 0,

      // Sticky trigger distance (header height + 200px buffer)
      stickyTrigger: 0,

      init() {
        // Calculate header height on initialization
        this.calculateHeaderHeight();

        // Set up scroll listener with debouncing for performance
        this.setupScrollListener();

        // Recalculate on window resize
        window.addEventListener('resize', () => {
          this.calculateHeaderHeight();
        });

        // Make methods globally available for other components
        window.scrollManager = {
          openDrawer: () => this.openDrawer(),
          closeDrawer: () => this.closeDrawer(),
          getState: () => ({
            isSticky: this.isSticky,
            isDrawerOpen: this.isDrawerOpen,
            scrollY: this.scrollY,
          }),
        };
      },

      calculateHeaderHeight() {
        const header = document.getElementById('site-header');
        if (header) {
          this.headerHeight = header.offsetHeight;
          this.stickyTrigger = this.headerHeight + 200; // 200px buffer
        }
      },

      setupScrollListener() {
        let ticking = false;

        const updateScrollPosition = () => {
          this.scrollY = window.scrollY;

          // Only update sticky state if no drawer is open
          if (!this.isDrawerOpen) {
            this.updateStickyState();
          }

          ticking = false;
        };

        window.addEventListener('scroll', () => {
          if (!ticking) {
            requestAnimationFrame(updateScrollPosition);
            ticking = true;
          }
        });
      },

      updateStickyState() {
        const shouldBeSticky = this.scrollY > this.stickyTrigger;

        if (shouldBeSticky !== this.isSticky) {
          this.isSticky = shouldBeSticky;
          this.applyHeaderStyling();
        }
      },

      applyHeaderStyling() {
        const header = document.getElementById('site-header');
        if (!header) return;

        if (this.isSticky && !this.isDrawerOpen) {
          header.classList.add('header--sticky');
          header.classList.remove('header--drawer-open');
        } else {
          header.classList.remove('header--sticky');
          if (this.isDrawerOpen) {
            header.classList.add('header--drawer-open');
          }
        }
      },

      openDrawer() {
        // Store current scroll position
        this.storedScrollPosition = window.scrollY;

        // Mark drawer as open
        this.isDrawerOpen = true;

        // Update header styling to remove sticky if active
        this.applyHeaderStyling();

        // Lock body scroll
        this.lockBodyScroll();
      },

      closeDrawer() {
        // Mark drawer as closed
        this.isDrawerOpen = false;

        // Unlock body scroll
        this.unlockBodyScroll();

        // Restore scroll position
        window.scrollTo(0, this.storedScrollPosition);

        // Update scroll position tracking
        this.scrollY = this.storedScrollPosition;

        // Re-evaluate sticky state
        this.updateStickyState();
      },

      lockBodyScroll() {
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'fixed';
        document.body.style.top = `-${this.storedScrollPosition}px`;
        document.body.style.width = '100%';
      },

      unlockBodyScroll() {
        document.body.style.overflow = '';
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
      },
    }));
  });
</script>
